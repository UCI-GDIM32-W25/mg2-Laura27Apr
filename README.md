[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/7qg5CCgx)
# HW2
## Devlog
During the breakdown activity in MG2, I revised my plan based on the professor's explanation. My initial plan was to divide the game into three parts: UI, Player, and Coins. The Player would handle only movement and jumping; the UI would handle only the score display; and the Coins would handle only coin movement and disappearance when colliding with the player. However, after reviewing the professor's example, I realized that this division would lead to overly fragmented logic, especially since coins are constantly generated, which makes updating the score and UI difficult. Therefore, I restructured it into Player, GameController, and Coins. The GameController would centrally manage the score and UI display, as well as handle coin generation. The Coins class would solely focus on detecting collisions with the player, adding points, and then destroying itself.


First, for the Player, I've outlined the necessary components in the inspector within my plan. The Transform component handles the player's position on the interface. The Sprite Renderer displays the player's sprite. The Rigidbody2D component enables the player to be affected by gravity and perform jumping physics. The Capsule Collider 2D component allows the player to collide with the ground to determine landing. At this point, I realized that I hadn't created the ground game object yet. I created a rectangle, added a Box Collider 2D to enable collisions with the player, and tagged it as "ground." In the code, I use the Start() method within the Player class and obtain the Rigidbody2D with the line of code: _rigidbody = GetComponent<Rigidbody2D>(). In Update(), I used Input.GetKeyDown(KeyCode.Space) to detect whether the player pressed the spacebar. I combined this with _isGrounded to restrict jumping to occur only on the ground. Specifically, when the space bar is pressed and _isGrounded is true, I set _isGrounded to false using the code. Then, I enable the player to jump upward using the code _rigidbody.velocity = new Vector2(_rigidbody.velocity.x, _jumpForce);. To ensure that jumps only occur after ground contact and prevent double jumps, I use the OnCollisionEnter2D method. This method checks for a GameObject named "Ground" through the CompareTag("Ground") function. The _isGrounded variable is only set to true when the player touches the ground, which allows the jump action to be triggered in the Update method via Input.GetKeyDown(KeyCode.Space).


Next, I finished the GameController section, which handles two main tasks: spawning coins and recording and displaying the player's score (points UI). In Unity's Inspector, I attached three key references to the GameController GameObject: TMP_Text _pointsText, which connects to the score display text (TextMeshPro) on the Canvas; GameObject _coinPrefab, which specifies the coin prefab to spawn; and Transform _spawnPoint, which determines the spawn location for each coin. I marked all three variables with [SerializeField], which allows them to remain private while still being editable via drag-and-drop in the Inspector. This ensures the script correctly references the scene's UI text and prefab. I then realized that I hadn't created the spawnPoint GameObject. I added one to the Hierarchy and positioned it where the coins should spawn. 


Within the GameController class, I used the Start() method to randomly generate a coin spawn interval using the Random.Range(0.2f, 1.5f) function and stored the result in the _spawnInterval variable. I simultaneously called UpdateUI() to display the initial score, which defaults to 0 points. In Update(), I incremented _spawnTimer by Time.deltaTime each frame to simulate a timer. When _spawnTimer is greater than or equal to _spawnInterval, it indicates that the time for coin generation has arrived. I call SpawnCoin() to generate a new coin, reset _spawnTimer to zero, and use Random.Range(0.2f, 1.5f) to set a new random generation interval. This ensures the coin spawn frequency isn't fixed entirely. Within the SpawnCoin() method, I create a new coin object using Instantiate(coinPrefab, spawnPoint.position, coinPrefab.transform.rotation) and store it as GameObject newCoin. Since the generated coin is a cloned prefab, I locate its Coin script using newCoin.GetComponent<Coin>() and assign the current GameController to it. coinScript.gameController = this; This step ensures that players can add points via the AddPoints() method when collecting coins. Without the GameController reference, the score cannot be updated correctly. Finally, to update the UI in real time when the score changes, I display the current score directly in the UpdateUI() method using _pointsText.text = "Points: + _points;. Within the AddPoints(int amount) method, I increment the _points variable by the specified amount and call the UpdateUI() method again. This completes the entire flow, from collecting coins to gaining points to updating the score.


Finally, regarding the coin, I've marked the components it requires in the inspector of my plan. First, the Sprite Renderer displays the coin's sprite. Second, the Collider2D detects when the player touches the coin. I need to check the "Is Trigger" box. This ensures that when the player touches the coin, it won't get "knocked away" or get stuck, but will simply be collected. To ensure stable detection via OnTriggerEnter2D(Collider2D other), I added a Rigidbody2D to the coin and set it to kinematic mode to prevent it from falling. Since the game features numerous coins, I saved the coin as a prefab. In the code, I control the coin's movement speed with the following line of code: [SerializeField] private float _moveSpeed = 2.5f; within the Coin class. In the Update() function, I continuously move the coin leftward via transform.position+=Vector3.left*_moveSpeed*Time.deltaTime. When the player collides with a coin, OnTriggerEnter2D(Collider2D other) is used to check if other.CompareTag("Player") is true. After confirming contact with the player, gameController.AddPoints(1) is called to increment the score, and Destroy(gameObject) is used to destroy the coin, completing the "collect coins to score points and then disappear" logic. Since the coin is a prefab, it doesn't inherently know which object in the scene is the game controller. Therefore, I set a public GameController gameController in the script and added an if statement to prevent reference-lost errors. This ensures that the coins reliably add points and disappear when collected.




## Open-Source Assets
If you added any other outside assets, list them here!
- [Sprout Lands sprite asset pack](https://cupnooble.itch.io/sprout-lands-asset-pack) - rabbit and item sprites
- [Pixel Penguin 32x32 Asset pack](https://legends-games.itch.io/pixel-penguin-32x32-asset-pack) - penguin sprites
- [Coins 2D](https://artist2d3d.itch.io/2d) - coin sprites